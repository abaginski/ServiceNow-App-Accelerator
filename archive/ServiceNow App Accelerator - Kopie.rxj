#!/usr/bin/rexx
-- imports
parse source . . absoluteFilepath

currPath = value("CLASSPATH",,"ENVIRONMENT")            -- get current value of the CLASSPATH environment variable
add2path = qualify("java/mysql-connector-java-5.1.43-bin.jar") || .file~pathseparator || - -- get the operating system specific absolute filepath to the necessary jar file
           qualify("java/unirest-java-1.4.9.jar") || .file~pathseparator || -
           qualify("java/jfoenix.jar") || .file~pathseparator
if currPath~pos(add2path) = 0 then do
    newPath = currPath || .file~pathseparator || add2path    -- append our paths to be looked up last
    originalPath = value("CLASSPATH", newPath, "ENVIRONMENT")   -- change PATH
    /* run the Application again making use of the new classpath */
    'rexxj "ServiceNow App Accelerator.rxj"'
    /* change PATH back to original and exit the application */
    call value "CLASSPATH", originalPath, "ENVIRONMENT"
    exit
end

dbName = "wissenschaftskompass"
call dbConnect dbName       -- execute the dbConnect routine with dbName as argument
statement = result~createStatement
dbData = .array~new     -- this variable will store all the information about this database

/*resultSet = statement~executeQuery("show databases")
say "Databases:"
loop while resultSet~next
    dbName = resultSet~getString("Database")
    say dbName
    dbData~append(dbName)
end
-- which of those databases do you want to import?
*/

--resultSet = statement~executeQuery("SELECT TABLE_NAME FROM information_schema.TABLES")
resultSet = statement~executeQuery("show tables")
columnHeading = "Tables_in_" || dbName
loop while resultSet~next
    tableName = resultSet~getString(columnHeading)
    table = .directory~new
    table~name = tableName
    dbData~append(table)
end

--todo: GUI l√∂scht Tabellen
dbData = .array~new
dbData[1] = .directory~new
dbData[1]~name = "artikel"

loop with index idx item table over dbData         -- iterate over the dbData array to perform an operation for each table
    --query = .jString~format("describe `%s`", tableName)
    resultSet = statement~executeQuery('describe `'table~name'`')
    /* create the "structure" entry for this table which will hold information about the columns */
    dbData[idx]~structure = .array~new
    loop while resultSet~next
        tableStructure = .directory~new
        tableStructure~Field = resultSet~getString("Field")
        tableStructure~Type = resultSet~getString("Type")
        tableStructure~Null = resultSet~getBoolean("Null")
        tableStructure~Key = resultSet~getString("Key")
        tableStructure~Default = resultSet~getString("Default")
        tableStructure~Extra = resultSet~getString("Extra")
        dbData[idx]~structure~append(tableStructure)
    end
end

say dbData[1]~name
say dbData[1]~structure[1]~Field
say dbData[1]~structure[2]~Field

/* now fill the dbData object with data for each table */

::routine dbConnect public
use arg dbName
/* Define your user-id and password to access the MySQL-DB*/
user = "root"
password = ""
/*Define the url to the database*/
-- for example for MySQL via jdbc on default-port 3306
url = "jdbc:mysql://localhost:3306/" || dbName;
/*Get the JDBC-Driver */
driver = .bsf~new('com.mysql.jdbc.Driver')
call bsf.import "java.sql.DriverManager", DriverManager
.DriverManager~registerDriver(driver)
/*Building the Connection*/
connection = .DriverManager~getConnection(url, user, password)
return connection

::requires "BSF.CLS" -- get Java Support